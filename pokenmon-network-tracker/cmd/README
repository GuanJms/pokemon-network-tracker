ğŸ”¥ Lab 1 (PokÃ©mon Edition): PokÃ©mon Sighting Fanout

ğŸ¯ Goal
	â€¢	A producer sends PokÃ©mon sightings.
	â€¢	Two trainer teams (consumers) each have their own queue.
	â€¢	Both teams listen for "pokemon.sighting" topic.
	â€¢	Each team gets every sighting.

ğŸŒ PokÃ©mon Sightings: System Story

ğŸ“– World Context

You are building a PokÃ©mon Tracker Network (PTN): a real-time messaging system that allows field agents to report PokÃ©mon sightings and trainer teams to subscribe and respond to them instantly.

ğŸ§ª Lab 2 Build Plan: PokÃ©mon Capture Squad

ğŸ” Goal:

Build a dispatcher that listens for "pokemon.sighting" and creates capture tasks pushed to a shared queue ("pokemon_tasks"), which are consumed by Team Rocket agents in competing consumer mode.

â¸»

âœ… Step 1: Create a Sighting Listener â†’ Capture Task Dispatcher

ğŸ”§ Goal

Write a Go function (startDispatcher) that:
	â€¢	Connects to RabbitMQ.
	â€¢	Declares:
	â€¢	pokemon_exchange (type: topic)
	â€¢	Queue: sightings_q (durable, non-exclusive)
	â€¢	Binds sightings_q to pokemon_exchange with routing key "pokemon.sighting".
	â€¢	Consumes from sightings_q.

Inside the handler:
	â€¢	Parse the PokÃ©mon and location.
	â€¢	Publish a new message to queue "pokemon_tasks" (use a new struct: CaptureTask{Pokemon, Location}).

ğŸ” Youâ€™re chaining message flows: consume from topic â†’ publish to queue

â¸»

âœ… Step 2: Implement Task Queue and Team Rocket Agents

ğŸ”§ Goal

Write startRocketAgent(id int):
	â€¢	Declare queue "pokemon_tasks" as durable and shared.
	â€¢	Start ch.Consume(...) on that queue.
	â€¢	Log which agent received which task.

Run 2â€“3 agents simultaneously to confirm load balancing of messages.

â¸»

âœ… Step 3: Trigger Some Sightings

Use your Lab 1 publisher to send 4â€“5 PokÃ©mon sightings with topic "pokemon.sighting":