🔥 Lab 1 (Pokémon Edition): Pokémon Sighting Fanout

🎯 Goal
	•	A producer sends Pokémon sightings.
	•	Two trainer teams (consumers) each have their own queue.
	•	Both teams listen for "pokemon.sighting" topic.
	•	Each team gets every sighting.

🌍 Pokémon Sightings: System Story

📖 World Context

You are building a Pokémon Tracker Network (PTN): a real-time messaging system that allows field agents to report Pokémon sightings and trainer teams to subscribe and respond to them instantly.

🧪 Lab 2 Build Plan: Pokémon Capture Squad

🔁 Goal:

Build a dispatcher that listens for "pokemon.sighting" and creates capture tasks pushed to a shared queue ("pokemon_tasks"), which are consumed by Team Rocket agents in competing consumer mode.

⸻

✅ Step 1: Create a Sighting Listener → Capture Task Dispatcher

🔧 Goal

Write a Go function (startDispatcher) that:
	•	Connects to RabbitMQ.
	•	Declares:
	•	pokemon_exchange (type: topic)
	•	Queue: sightings_q (durable, non-exclusive)
	•	Binds sightings_q to pokemon_exchange with routing key "pokemon.sighting".
	•	Consumes from sightings_q.

Inside the handler:
	•	Parse the Pokémon and location.
	•	Publish a new message to queue "pokemon_tasks" (use a new struct: CaptureTask{Pokemon, Location}).

🔁 You’re chaining message flows: consume from topic → publish to queue

⸻

✅ Step 2: Implement Task Queue and Team Rocket Agents

🔧 Goal

Write startRocketAgent(id int):
	•	Declare queue "pokemon_tasks" as durable and shared.
	•	Start ch.Consume(...) on that queue.
	•	Log which agent received which task.

Run 2–3 agents simultaneously to confirm load balancing of messages.

⸻

✅ Step 3: Trigger Some Sightings

Use your Lab 1 publisher to send 4–5 Pokémon sightings with topic "pokemon.sighting":